---
output: github_document
---



<!-- README.md is generated from README.Rmd. Please edit that file -->
<div id="introduction" class="section level1">
<h1>Introduction</h1>
<p>Continuing with the previous article <a href="http://blog.oilgainsanalytics.com/publications/the-fabrication-of-an-artificial-intelligence-agent-for-reservoir-history-matching-from-the-volve-dataset/">The fabrication of an artificial intelligence agent for reservoir history matching from the Volve dataset</a>, and the generation of a master dataset for an AI agent to perform history matching of reservoir models, we will extract additional data from the output of the Volve reservoir model, the <code>PRT</code> text file. This is the output “as-is”, as we found it. No additional simulation runs have been performed over this model.</p>
<p>In addition to the PRT file there are binary files that Eclipse generates as part of the output. We still don’t have a reader for those files but we are close to take a look at some code written in Python by a Reservoir Engineer who I have been in touch for the past few days. Working with binary files should be your more preferred option than dealing with the painful extraction of variables using regular expressions (regex). At any rate, we could take these last two posts as an exercise of applying regex to text files when we don’t have access to the binary files format.</p>
<div id="data-blocks-in-the-simulator-output" class="section level2">
<h2>Data blocks in the simulator output</h2>
<p>In the previous article, we extracted the <strong>field totals</strong>, or cumulatives, from the text blocks with the keyword <strong>BALANCE AT</strong> in the <code>PRT</code> file; produced volumes of oil, gas and water as well as the COIP, or currently oil in place. There is another block of interest in the text file, that we could call the <strong>STEP</strong> block. This block contains instantaneous production variables such as GOR, watercut, WGR and the average bottomhole pressure (PAV). WHat we are looking here is to improve the current dataset from containing cumulative volumes to include these new production variables. In other other words, we want a more comprehensive dataset that we could use as part of a machine learning algorithm later.</p>
</div>
<div id="challenges-ahead" class="section level2">
<h2>Challenges ahead</h2>
<p>There are some challenges though while doing this:</p>
<ul>
<li><p>The number of observations (rows) of the variables extracted from the <strong>STEP</strong> block is greater than the observations of the field totals dataset.</p></li>
<li><p>Since the data originated from the <strong>STEP</strong> block is more granular than that of the <strong>BALANCE-AT</strong> block, we will face the challenge of mismatched dates between both. So, a more complete dataset of production variables comes with its costs. Merging two dataframes will have to be carefully performed.</p></li>
<li><p>Additionally, we may not getting all the variables from the <strong>PRT</strong> text file as from the binary files generated by Eclipse. As one of the reservoir engineers, who read the previous article, noticed there is an inconsistency in the <strong>produced water</strong> between the PRT file values I got and the binary files he was able to read. This is one of the drawbacks of reading the <strong>PRT</strong> text file and mining for data; it is difficult to find all the output variables from the simulation, and some of them -if not properly identified- could be misleading.</p></li>
<li><p>While the extraction of data from a text file serves a purpose, when a reader of binary files from the simulation is not available, we should exercise caution with those extracted from a text file.</p></li>
<li><p>It is nice to get a good match of volumes between simulation and the real world. But we also have to be prepared for the bad news: when one of the reservoir fluids is far, far away from the match.</p></li>
</ul>
</div>
</div>
<div id="read-the-simulation-output-data" class="section level1">
<h1>Read the simulation output data</h1>
<div id="read-the-prt-text-file" class="section level2">
<h2>Read the PRT text file</h2>
<p>As we did in the previous step, we start by reading the reservoir simulation output file: the text file <strong>VOLVE_2016.PRT`</strong>. It is a relatively big file: 228 megabytes. I have zipped it in order to save some disk space and prevent Github from complaining about the size of the file. Maximum size of a file in Github is 100 megabytes.</p>
<p>This data operation was shown in the previous article with the only difference that I used Google drive instead. In a second case, I used Zenodo, a service that allows sharing datasets up to 50 gigabytes per dataset. I am providing the links to the datasets living in Zenodo at the end of this article.</p>
<pre class="r"><code>library(dplyr)
library(ggplot2)

# read the Eclipse PRT output report
proj_root &lt;- rprojroot::find_rstudio_root_file()
# had to zip the PRT file because it&#39;s 225 MB and too big for Github
volve_2016_zip &lt;- file.path(proj_root, &quot;inst/rawdata&quot;, &quot;VOLVE_2016.zip&quot;)
temp &lt;- tempdir()

volve_2016_txt &lt;- readLines(unzip(volve_2016_zip, exdir = temp))</code></pre>
<p>Once with the contents of <code>VOLVE_2016.PRT</code> loaded in the object <strong>volve_2016_txt</strong>, we proceed to perform the extraction.</p>
<p>We start by extracting few rows after the <strong>STEP</strong> keyword.</p>
<pre class="r"><code># get a list of rows from &quot; STEP&quot; 

# find the rows where we find the word &quot; STEP&quot;
step_rows &lt;- grep(&quot;^ STEP&quot;, volve_2016_txt)

# add rows ahead to where the keyword was found
step_info_range &lt;- lapply(seq_along(step_rows), function(x) 
    c(step_rows[x], step_rows[x]+1:2))               # add two extra row indices

step_info_range[[1]]   # sample for report page 1 only
#&gt; [1] 1548178 1548179 1548180</code></pre>
<p>These extra row indices are lines of text where the report keeps more information of the evolution of the simulation. Here is a couple of screenhots.</p>
<p>Step at day <strong>1</strong>:</p>
<div class="figure" style="text-align: center"><span id="fig:unnamed-chunk-2"></span>
<img src="img/step_0001.png" alt="Step at 1 day" width="600px" />
<p class="caption">
Figure 1: Step at 1 day
</p>
</div>
<p>Step at day <strong>3,197</strong>:</p>
<div class="figure" style="text-align: center"><span id="fig:unnamed-chunk-3"></span>
<img src="img/step_3197.png" alt="Step at 3197 days" width="600px" />
<p class="caption">
Figure 2: Step at 3197 days
</p>
</div>
<p>Now, knowing the row indices for the text we need to extract from the <code>PRT</code> file, we can proceed to extracting those lines of text and putting them in a list, one page or one step, per list element. We do this to later iterate through all the steps and extract the data we want. The object <code>steps_info_txt_pages</code> is a list containing the row indices that are of our interest.</p>
<pre class="r"><code># get the text from all pages and put them in a list
steps_info_txt_pages &lt;- lapply(seq_along(step_info_range), function(x) 
    volve_2016_txt[step_info_range[[x]]])</code></pre>
<p>For example, this is an example of the first page for step #1.</p>
<pre class="r"><code>steps_info_txt_pages[1]
#&gt; [[1]]
#&gt; [1] &quot; STEP    1 TIME=      1.00  DAYS (    +1.0  DAYS INIT  5 ITS) (1-JAN-2008)       &quot;
#&gt; [2] &quot;  PAV=   329.6  BARSA  WCT= 0.00 GOR= 0.00000   SM3/SM3 WGR= 0.00000   SM3/SM3   &quot;
#&gt; [3] &quot;&quot;</code></pre>
</div>
<div id="extracting-step-data-from-the-text-file" class="section level2">
<h2>Extracting step data from the text file</h2>
<div id="extract-the-days-from-the-step-block" class="section level3">
<h3>Extract the days from the STEP block</h3>
<p>Although we could extract all the data we require from the text file in one go, it is better to see one or two examples of seeing <strong>regular expressions</strong> or <strong>regex</strong> at work. Regular expressions are practically available to all programming languages: C++, Java, JavaScript, Python, Perl, R, etc.</p>
<p>In this first example, we will extract the number of days at the current simulation step. If this is the first step page:</p>
<pre><code> STEP    1 TIME=      1.00  DAYS (    +1.0  DAYS INIT  5 ITS) (1-JAN-2008)       
  PAV=   329.6  BARSA  WCT= 0.00 GOR= 0.00000   SM3/SM3 WGR= 0.00000   SM3/SM3</code></pre>
<p>to extract the days we have to provide a regex pattern that detects a real number like <code>1.00</code>, which is <code>&quot;.*?(\\d+.\\d.)+.*&quot;</code>.</p>
<p><strong>Explanation</strong></p>
<ul>
<li><code>.*?</code> will match any characters. lazy matching.</li>
<li><code>(\\d+.\\d.)</code> capturing group.</li>
<li><code>\\d+</code> matches any number of digits</li>
<li><code>\\d.</code> matches a digit and then any character</li>
</ul>
<p>Here we iterate through the list <em>steps_info_txt_pages</em>, extract the step-page, extract the number of days from the text. After that, we convert the vector to a dataframe.</p>
<pre class="r"><code># iterate through the list of STEP pages
days_dfs &lt;- lapply(seq_along(steps_info_txt_pages), function(x) {
    page &lt;- steps_info_txt_pages[[x]]   # put all pages text in a list
    days_row_txt &lt;- page[1]                                # get 1st row of page
    days_value &lt;- sub(&quot;.*?(\\d+.\\d.)+.*&quot;, &quot;\\1&quot;, days_row_txt,
                      perl = TRUE) # extract the days
    
    # dataframe; days as double; no factors.
    data.frame(days = as.double(days_value), stringsAsFactors = FALSE) 
})

days_df &lt;- do.call(&quot;rbind&quot;, days_dfs)</code></pre>
</div>
<div id="extract-the-days" class="section level3">
<h3>Extract the days</h3>
<p>Let’s see a sample of the first ten and last ten rows for the dataframe <em>days_df</em> just extracted:</p>
<pre class="r"><code>rbind(head(days_df, 10), tail(days_df, 10))   # show the first 10 and last 10 rows
#&gt;         days
#&gt; 1       1.00
#&gt; 2       1.63
#&gt; 3       2.32
#&gt; 4       3.50
#&gt; 5       5.45
#&gt; 6       8.22
#&gt; 7      11.00
#&gt; 8      14.61
#&gt; 9      17.80
#&gt; 10     21.00
#&gt; 1601 1601.00
#&gt; 1602 1602.00
#&gt; 1603 1603.00
#&gt; 1604 1604.00
#&gt; 1605 1605.00
#&gt; 1606 1606.00
#&gt; 1607 1607.00
#&gt; 1608 1608.00
#&gt; 1609 1609.00
#&gt; 1610 1610.00</code></pre>
<p>This is just 20 rows of data. The dataframe <em>days_df</em> has 1610 observations or rows.</p>
</div>
<div id="extract-the-simulator-running-date" class="section level3">
<h3>Extract the simulator running date</h3>
<p>This is the second example of data extraction using <em>regex</em>.</p>
<p>The following regular expresion pattern extracts the date from the current text line.</p>
<p><strong>Explanation</strong></p>
<ul>
<li><code>.*?(\\d{1,2}-[A-Z]{3}-\\d{4}).</code> entire regex pattern<br />
</li>
<li><code>(\\d{1,2}-[A-Z]{3}-\\d{4})</code> parenthesis indicate a group to extract the date<br />
</li>
<li><code>.*?</code> match any character<br />
</li>
<li><code>\\d{1,2}</code> match one or two digits (day)<br />
</li>
<li><code>-[A-Z]{3}</code> match a dash followed by three letters (month)<br />
</li>
<li><code>-\\d{4}</code> match four digits (year)</li>
</ul>
<p>Again, we iterate through the list <em>steps_info_txt_pages</em>, select a step-page, and then extract the date. Notice the difference between the previous <em>regex</em> and this one for capturing the date.</p>
<pre class="r"><code># iterate through the list of pages: dates
date_dfs &lt;- lapply(seq_along(steps_info_txt_pages), function(x) {
    page &lt;- steps_info_txt_pages[[x]]  # put all pages text in a list
    date_row_txt &lt;- grep(&quot; STEP&quot;, page)  # get row index at word STEP
    date_value &lt;- sub(&quot;.*?(\\d{1,2}-[A-Z]{3}-\\d{4}).&quot;, &quot;\\1&quot;, page[date_row_txt])
    
    # dataframe; no factors
    data.frame(date = date_value, stringsAsFactors = FALSE) 
})

date_df &lt;- do.call(&quot;rbind&quot;, date_dfs)

# size of the dataframe: rows by columns
dim(date_df)
#&gt; [1] 1610    1

rbind(head(date_df, 10), tail(date_df, 10))   # show the first 10 and last 10 rows
#&gt;                   date
#&gt; 1    1-JAN-2008       
#&gt; 2    1-JAN-2008       
#&gt; 3    2-JAN-2008       
#&gt; 4    3-JAN-2008       
#&gt; 5    5-JAN-2008       
#&gt; 6    8-JAN-2008       
#&gt; 7    11-JAN-2008      
#&gt; 8    14-JAN-2008      
#&gt; 9    17-JAN-2008      
#&gt; 10   21-JAN-2008      
#&gt; 1601 17-SEP-2016      
#&gt; 1602 20-SEP-2016      
#&gt; 1603 20-SEP-2016      
#&gt; 1604 20-SEP-2016      
#&gt; 1605 20-SEP-2016      
#&gt; 1606 21-SEP-2016      
#&gt; 1607 23-SEP-2016      
#&gt; 1608 25-SEP-2016      
#&gt; 1609 28-SEP-2016      
#&gt; 1610 1-OCT-2016</code></pre>
<p>This second dataframe <em>date_df</em> also has 1610 rows. You see a kind of a pattern here, right? We are extracting columns with the same number of observations (rows).</p>
</div>
<div id="extract-all-the-values-from-the-step-block" class="section level3">
<h3>Extract all the values from the <strong>STEP</strong> block</h3>
<p>After showing this pair of examples, we continue with the extraction of the rest of the values. If you take a look at the PRT file you will recognize these as the variables to be extracted:</p>
<ul>
<li><code>STEP</code> simulation step number</li>
<li><code>TIME</code> number of days elapsed at the simulation step</li>
<li><code>date</code> current date at the simulation run</li>
<li><code>PAV</code> average pressure</li>
<li><code>WCT</code> watercut</li>
<li><code>GOR</code> gas oil ratio</li>
<li><code>WGR</code> water gas ratio</li>
</ul>
<p>The mission here is to extract all the variables that are made available by the simulator in the <strong>STEP</strong> block. As shown above, they are seven variables. The two previous examples were showing the work for two of these variables.</p>
<p>The following is an <strong>R</strong> script that extracts all the variables from all the occurrences of the <strong>STEP</strong> block in the <strong>PRT</strong> file.</p>
<p>Something that we need to know: the steps are not entirely sequential. They may skip a day, or more, or could have been generated after “few hours” in the simulation, and they do not necessarily match the date in the <em>field totals</em> dataframe. This is something to consider. Both dataframes will have different number of rows.</p>
<p>What is new here is that I am extracting several values from the text in one shot: <strong>step</strong> (group 1), <strong>days</strong> (group 2), and <strong>date</strong> (group 4). Then assign them to their respective memory objects. A second thing that we do here -and very common in text files-, is the correction of the short name of the month. I am not sure what the reservoir guys were thinking about, but they decided to baptize the month of <strong>July</strong> as <strong>JLY</strong>, when the standard practice is to short-name it <strong>JUL</strong>. Anyway, the side effect of this is that at the moment of converting character to date formats, the date using <strong>JLY</strong> will be translated as <em>NULL</em>, since the date converter doesn’t know anything about a month short-called <strong>JLY</strong>. I didn’t know this in advance, but examining the output I found some gaps in the output that didn’t show up in the raw data. So, be mindful of these events.</p>
<pre class="r"><code># script that extracts production variables from the simulator output
library(lubridate)

# get the row indices where we find the keyword &quot; STEP&quot;
step_rows &lt;- grep(&quot;^ STEP&quot;, volve_2016_txt)

# get rows ahead range. by block of text or per page
# in the case of the STEP block we are only interested in the next two rows
step_info_range &lt;- lapply(seq_along(step_rows), function(x) 
    c(step_rows[x], step_rows[x]+1:2))

# get the text from all STEP pages and store each in a list element
steps_info_txt_pages &lt;- lapply(seq_along(step_info_range), function(x) 
    volve_2016_txt[step_info_range[[x]]])

# iterate through the list of pages for the STEP blocks in the report
step_info_dfs &lt;- lapply(seq_along(steps_info_txt_pages), function(x) {
    page &lt;- steps_info_txt_pages[[x]]             # load a STEP block/page
    
    # this is line 1
    row_txt &lt;- grep(&quot; STEP&quot;, page)  # line 1 starts with STEP
    # pattern extraction for 1st line of text: STEP, TIME, date
    line_1_pattern &lt;- &quot;.*?(\\d+)+.*?(\\d+.\\d+)+.*?(\\d+)+.*?(\\d{1,2}-[A-Z]{3}-\\d{4})+.*&quot;
    step_value &lt;- sub(line_1_pattern, &quot;\\1&quot;, page[row_txt], perl = TRUE) # extract step
    days_value &lt;- sub(line_1_pattern, &quot;\\2&quot;, page[row_txt], perl = TRUE) # extract days
    date_value &lt;- sub(line_1_pattern, &quot;\\4&quot;, page[row_txt], perl = TRUE) # extract date
    date_value &lt;- sub(&quot;JLY&quot;, &quot;JUL&quot;, date_value)              # change JLY by JUL
    
    
    # this is line 2
    row_txt &lt;- grep(&quot; PAV&quot;, page) # line 2 starts with PAV=
    # pattern extraction for 2nd line of text: PAV, WCT, GOR, WGR
    line_2_pattern &lt;- &quot;.*?(\\d+.\\d+)+.*?(\\d+.\\d+)+.*?(\\d+.\\d+)+.*?(\\d+.\\d+).*&quot;
    pav_value &lt;- sub(line_2_pattern, &quot;\\1&quot;, page[row_txt], perl = TRUE) # Get avg pres
    wct_value &lt;- sub(line_2_pattern, &quot;\\2&quot;, page[row_txt], perl = TRUE) # get WCT
    gor_value &lt;- sub(line_2_pattern, &quot;\\3&quot;, page[row_txt], perl = TRUE) # get GOR
    wgr_value &lt;- sub(line_2_pattern, &quot;\\4&quot;, page[row_txt], perl = TRUE) # get WGR
    
    # dataframe; 
    data.frame(step = as.integer(step_value), 
               date = dmy(date_value),
               time_days = as.double(days_value), 
               pav_bar   = as.double(pav_value),
               wct_pct   = as.double(wct_value),
               gor_m3m3  = as.double(gor_value), 
               wgr_m3m3  = as.double(wgr_value),
               stringsAsFactors = FALSE) 
})

step_info &lt;- do.call(&quot;rbind&quot;, step_info_dfs) # put together all dataframes in list

# show a summary of the dataframe
glimpse(step_info)
#&gt; Observations: 1,610
#&gt; Variables: 7
#&gt; $ step      &lt;int&gt; 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 1...
#&gt; $ date      &lt;date&gt; 2008-01-01, 2008-01-01, 2008-01-02, 2008-01-03, 200...
#&gt; $ time_days &lt;dbl&gt; 1.00, 1.63, 2.32, 3.50, 5.45, 8.22, 11.00, 14.61, 17...
#&gt; $ pav_bar   &lt;dbl&gt; 329.6, 329.6, 329.6, 329.6, 329.6, 329.6, 329.6, 329...
#&gt; $ wct_pct   &lt;dbl&gt; 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0...
#&gt; $ gor_m3m3  &lt;dbl&gt; 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00...
#&gt; $ wgr_m3m3  &lt;dbl&gt; 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0...</code></pre>
<p>Finally, we get all the vectors for <strong>step</strong> number, <strong>date</strong>, <strong>date</strong>, average <strong>pressure</strong>, <strong>watercut</strong>, <strong>GOR</strong> and <strong>WGR</strong> in a dataframe.</p>
<p>Then, we show the dataframe as a <em>tibble</em>, which is an elegant way of presenting long dataframes. This dataframe <em>step_info</em>, in particular, has 1610 rows and 7 columns.</p>
<pre class="r"><code># show as a tibble
(step_info &lt;- as_tibble(step_info))
#&gt; # A tibble: 1,610 x 7
#&gt;     step date       time_days pav_bar wct_pct gor_m3m3 wgr_m3m3
#&gt;    &lt;int&gt; &lt;date&gt;         &lt;dbl&gt;   &lt;dbl&gt;   &lt;dbl&gt;    &lt;dbl&gt;    &lt;dbl&gt;
#&gt;  1     1 2008-01-01      1       330.       0        0        0
#&gt;  2     2 2008-01-01      1.63    330.       0        0        0
#&gt;  3     3 2008-01-02      2.32    330.       0        0        0
#&gt;  4     4 2008-01-03      3.5     330.       0        0        0
#&gt;  5     5 2008-01-05      5.45    330.       0        0        0
#&gt;  6     6 2008-01-08      8.22    330.       0        0        0
#&gt;  7     7 2008-01-11     11       330.       0        0        0
#&gt;  8     8 2008-01-14     14.6     330.       0        0        0
#&gt;  9     9 2008-01-17     17.8     330.       0        0        0
#&gt; 10    10 2008-01-21     21       330.       0        0        0
#&gt; # ... with 1,600 more rows</code></pre>
<p>These are the names of the variables in the dataframe:</p>
<pre class="r"><code>names(step_info)
#&gt; [1] &quot;step&quot;      &quot;date&quot;      &quot;time_days&quot; &quot;pav_bar&quot;   &quot;wct_pct&quot;   &quot;gor_m3m3&quot; 
#&gt; [7] &quot;wgr_m3m3&quot;</code></pre>
<p>You can see that the <strong>STEP</strong> block does not carry any data regarding cumulative production.</p>
</div>
<div id="a-sample-of-the-step_info-dataframe" class="section level3">
<h3>A Sample of the <em>step_info</em> dataframe</h3>
<p>Let’s test the first day and last day of the simulation:</p>
<pre class="r"><code>tail(step_info$date,1) - head(step_info$date,1)
#&gt; Time difference of 3196 days</code></pre>
<p>The simulation runs for 3196 days of the reservoir life.</p>
</div>
<div id="save-to-data-files" class="section level3">
<h3>Save to data files</h3>
<p>Now, let’s save the data as a <em>.Rdata</em> file (readable from R) and as as <em>CSV</em> file (capable of being imported practically by any software).</p>
<pre class="r"><code>data_folder &lt;- file.path(proj_root, &quot;data&quot;)   # project folder
# full filename, including path
save(step_info, file = file.path(data_folder, &quot;data_from_step.Rdata&quot;))
write.csv(step_info, file = file.path(data_folder, 
                                         &quot;data_from_step.CSV&quot;), 
          row.names = FALSE)</code></pre>
</div>
<div id="plots-from-the-step-block" class="section level3">
<h3>Plots from the step block</h3>
<p>Next, we proceed to show some of the data as visualization output. Here we will use the R package <strong>ggplot2</strong>. This is a flexible and sophisticated visualization tool using the Grammar of Graphics. These will be very simple plots of the variables we just extracted.</p>
<div id="plot-pressure-vs-time" class="section level4">
<h4>Plot pressure vs time</h4>
<p>Let’s take a look at the pressure over the life of the field, from the simulator perspective.</p>
<pre class="r"><code>ggplot(step_info, aes(x =date, y = pav_bar)) +
    geom_line(color = &quot;red&quot;) +
    labs(title = &quot;Pressure over time&quot;, subtitle = &quot;Simulator output&quot;,
         y = &quot;Average Pressure (PAV), bar&quot;)</code></pre>
<p><img src="/publications/external/volve-reservoir-model-evolution/README_files/figure-html/unnamed-chunk-14-1.png" width="672" style="display: block; margin: auto;" /></p>
</div>
<div id="plot-watercut-vs-time" class="section level4">
<h4>Plot watercut vs time</h4>
<pre class="r"><code># plot from PRT simulator output (STEP block)
ggplot(step_info, aes(x =date, y = wct_pct)) +
    geom_line(color = &quot;blue&quot;) +
    labs(title = &quot;Field watercut over time&quot;, subtitle = &quot;Simulator output&quot;,
         y = &quot;Watercut, percent&quot;)</code></pre>
<p><img src="/publications/external/volve-reservoir-model-evolution/README_files/figure-html/unnamed-chunk-15-1.png" width="672" style="display: block; margin: auto;" /></p>
</div>
</div>
<div id="plot-all-variables-from-step-block" class="section level3">
<h3>Plot all variables from <code>STEP</code> block</h3>
<p>To prevent cluttering our report from lots of plots, we will show all plots in one figure using <strong>facets</strong>. In order to achieve this, we will have to transform our data in <strong>tidy format</strong>.</p>
<pre class="r"><code>library(tidyr)

# convert to tidy format
step_info_gather &lt;- 
step_info %&gt;% 
  select(-c(step, time_days)) %&gt;% 
  gather(key = var, value, pav_bar:wgr_m3m3) %&gt;% 
  print()
#&gt; # A tibble: 6,440 x 3
#&gt;    date       var     value
#&gt;    &lt;date&gt;     &lt;chr&gt;   &lt;dbl&gt;
#&gt;  1 2008-01-01 pav_bar  330.
#&gt;  2 2008-01-01 pav_bar  330.
#&gt;  3 2008-01-02 pav_bar  330.
#&gt;  4 2008-01-03 pav_bar  330.
#&gt;  5 2008-01-05 pav_bar  330.
#&gt;  6 2008-01-08 pav_bar  330.
#&gt;  7 2008-01-11 pav_bar  330.
#&gt;  8 2008-01-14 pav_bar  330.
#&gt;  9 2008-01-17 pav_bar  330.
#&gt; 10 2008-01-21 pav_bar  330.
#&gt; # ... with 6,430 more rows
  
# plot production variables from the STEP block in the PRT file

# change the name of the facet labels
facet_labels &lt;- c(`gor_m3m3` = &quot;GOR, m3/m3&quot;, `pav_bar` = &quot;Avg.Pres, bar&quot;,
                  `wct_pct` = &quot;Watercut, %&quot;, `wgr_m3m3` = &quot;Water Gas Ratio, m3/m3&quot;)

# plot the facets with free y-axis.
ggplot(step_info_gather, aes(x = date, y = value)) +
  geom_line() +
  facet_wrap(.~var, scales = &quot;free_y&quot;, labeller = as_labeller(facet_labels)) +
  labs(title = &quot;Production variables from STEP block&quot;, 
       subtitle = &quot;Simulator output&quot;, y = &quot;&quot;, x = &quot;&quot;)</code></pre>
<p><img src="/publications/external/volve-reservoir-model-evolution/README_files/figure-html/unnamed-chunk-16-1.png" width="672" style="display: block; margin: auto;" /></p>
</div>
</div>
<div id="merge-cumulative-oil-with-simulator-steps" class="section level2">
<h2>Merge cumulative oil with simulator steps</h2>
<p>Next step is combining the data from the <em>steps</em> dataframe with the <em>balance-at</em> production cumulatives. This is not an straight operation since both dataframes have different date references.</p>
<ol style="list-style-type: decimal">
<li><p>First, we will extract the production cumulatives (field totals) from the PRT file. This is something we already did in the previous article. We will load that script.</p></li>
<li><p>Save the production cumulatives dataframe as a CSV file.</p></li>
<li><p>Join the field_totals and step_info dataframe by a common variable.</p></li>
<li><p>Plot variables</p></li>
<li><p>Calculate cumulatives</p></li>
<li><p>Fix the dates in the merge dataframe so they are continuous from 2018 till October 2016.</p></li>
<li><p>Calculate cumulatives and volumes by month</p></li>
</ol>
</div>
<div id="extract-field-cumulatives-from-the-balance-at-block" class="section level2">
<h2>Extract Field cumulatives from the <code>BALANCE-AT</code> block</h2>
<pre class="r"><code># load a script with functions
r_folder &lt;- file.path(proj_root, &quot;R&quot;)
r_script &lt;- file.path(r_folder, &quot;extract_data_from_prt.R&quot;)
source(r_script)

# run function to extract field totals or cumulative production
field_totals &lt;- extract_field_totals(prt_file_content = volve_2016_txt)
field_totals
#&gt; # A tibble: 340 x 8
#&gt;    date        days     ocip     ooip oil_otw wat_otw  gas_otw   pav
#&gt;    &lt;date&gt;     &lt;int&gt;    &lt;dbl&gt;    &lt;dbl&gt;   &lt;dbl&gt;   &lt;dbl&gt;    &lt;dbl&gt; &lt;dbl&gt;
#&gt;  1 2007-12-31     0 21967455 21967455       0       0        0  330.
#&gt;  2 2008-01-11    11 21967456 21967455       0       0        0  330.
#&gt;  3 2008-01-21    21 21967455 21967455       0       0        0  330.
#&gt;  4 2008-01-31    31 21967454 21967455       0       0        0  330.
#&gt;  5 2008-02-10    41 21967454 21967455       0       0        0  330.
#&gt;  6 2008-02-20    51 21948189 21967455   19265       0  3055593  325.
#&gt;  7 2008-02-26    57 21936614 21967455   30840       0  4884638  323.
#&gt;  8 2008-03-01    61 21925419 21967455   42035       0  6650055  320.
#&gt;  9 2008-03-11    71 21897024 21967455   70430       0 11113293  314.
#&gt; 10 2008-03-21    81 21867231 21967455  100223       1 15777548  308.
#&gt; # ... with 330 more rows</code></pre>
<div id="save-field-totals-to-data-files" class="section level4">
<h4>Save field totals to data files</h4>
<pre class="r"><code># save the data
data_folder &lt;- file.path(proj_root, &quot;data&quot;)
save(field_totals, file = file.path(data_folder, &quot;field_totals_balance.Rdata&quot;))
write.csv(field_totals, file = file.path(data_folder, 
                                         &quot;field_totals_balance.CSV&quot;), 
          row.names = FALSE)</code></pre>
<p>We quickly plot the water outflow over the years.</p>
<blockquote>
<p>Note. This data might not correct. The PRT file does not explicitely assign a variable for the water outflow. Besides, this volume comes with a negative sign, which indicates injection rather than water production.</p>
</blockquote>
<pre class="r"><code># plot from PRT simulator output (BALANCE AT block)
ggplot(field_totals, aes(x =date, y = wat_otw)) +
    geom_line(color = &quot;blue&quot;) +
    labs(title = &quot;Field Water Outflow Through Wells&quot;, 
         subtitle = &quot;Simulator output, BALANCE block&quot;,
         y = &quot;Water volume, sm3&quot;)</code></pre>
<p><img src="/publications/external/volve-reservoir-model-evolution/README_files/figure-html/unnamed-chunk-19-1.png" width="672" style="display: block; margin: auto;" /></p>
<p>Now, we know that the STEP dataframe has more rows than the BALANCE-AT dataframe. What we want is to correlate the step with the oil cumulatives.</p>
<p>These are the rows in the <em>step_info</em> dataframe:</p>
<pre class="r"><code>dim(step_info)
#&gt; [1] 1610    7</code></pre>
<p>These are the number of rows and colums of the <em>field_totals</em> dataframe.</p>
<pre class="r"><code>dim(field_totals)
#&gt; [1] 340   8</code></pre>
</div>
</div>
<div id="join-field-totals-and-step-dataframes" class="section level2">
<h2>Join field totals and step dataframes</h2>
<p>We merge both tables, steps and field cumulatives. The resultant dataframe we call it <em>step_totals</em>.</p>
<pre class="r"><code># join both tables by the common variable &quot;date&quot;
step_totals &lt;- 
left_join(step_info, field_totals, by = &quot;date&quot;) %&gt;% 
    na.omit() %&gt;% 
    select(date, time_days, days, everything()) %&gt;% 
    as_tibble() %&gt;% 
    print
#&gt; # A tibble: 524 x 14
#&gt;    date       time_days  days  step pav_bar wct_pct gor_m3m3 wgr_m3m3
#&gt;    &lt;date&gt;         &lt;dbl&gt; &lt;int&gt; &lt;int&gt;   &lt;dbl&gt;   &lt;dbl&gt;    &lt;dbl&gt;    &lt;dbl&gt;
#&gt;  1 2008-01-11      11      11     7    330.       0       0         0
#&gt;  2 2008-01-21      21      21    10    330.       0       0         0
#&gt;  3 2008-01-31      31      31    13    330.       0       0         0
#&gt;  4 2008-02-10      41      41    15    330.       0       0         0
#&gt;  5 2008-02-20      51      51    17    325.       0     158.        0
#&gt;  6 2008-02-26      57      57    18    323.       0     158.        0
#&gt;  7 2008-03-01      61      61    19    320.       0     158.        0
#&gt;  8 2008-03-11      71      71    21    314.       0     157.        0
#&gt;  9 2008-03-21      81      81    23    308.       0     156.        0
#&gt; 10 2008-03-21      81.5    81    24    308        0     156.        0
#&gt; # ... with 514 more rows, and 6 more variables: ocip &lt;dbl&gt;, ooip &lt;dbl&gt;,
#&gt; #   oil_otw &lt;dbl&gt;, wat_otw &lt;dbl&gt;, gas_otw &lt;dbl&gt;, pav &lt;dbl&gt;</code></pre>
<p>The dataframe step_totals has 524 rows or observations and 14 columns or variables.</p>
<p>Looking at this dataframe closer we observe that the date intervals is not uniform; it is not weekle, bi-weekly or monthly because it is a merged dataframe. What we will do next is transforming this dataframe to a monthly summary or where the date intervals is a month separation.</p>
<div id="plot-outflow-through-wells-from-simulator" class="section level3">
<h3>Plot outflow through wells from simulator</h3>
<p>Without additional data transformations we plot the cumulatives of the merged dataset.</p>
<pre class="r"><code>ggplot(step_totals, aes(x = date, y = oil_otw)) +
    geom_line(color = &quot;dark green&quot;, size = 1.1) +
    ggtitle(&quot;Cumulative Oil, sm3&quot;, subtitle = &quot;Simulator&quot;)</code></pre>
<p><img src="/publications/external/volve-reservoir-model-evolution/README_files/figure-html/unnamed-chunk-23-1.png" width="672" style="display: block; margin: auto;" /></p>
<p>This ggplot for the cumulative gas.</p>
<pre class="r"><code>ggplot(step_totals, aes(x = date, y = gas_otw)) +
    geom_line(color = &quot;orange&quot;, size = 1.1) +
    labs(title = &quot;Cumulative Gas&quot;, subtitle = &quot;Simulator&quot;,
         y = &quot;Cumulative Gas, sm3&quot;)</code></pre>
<p><img src="/publications/external/volve-reservoir-model-evolution/README_files/figure-html/unnamed-chunk-24-1.png" width="672" style="display: block; margin: auto;" /></p>
<p>And this another one for cumulative water.</p>
<p>Let’s just keep in mind that this curve may not be right because we are extracting from an incorrect labeled column (water outflow from wells).</p>
<pre class="r"><code>ggplot(step_totals, aes(x = date, y = wat_otw)) +
    geom_line(color = &quot;blue&quot;, size = 1.1) +
    labs(title = &quot;Cumulative Water&quot;, subtitle = &quot;Simulator&quot;,
         y = &quot;Cumulative Water, sm3&quot;)</code></pre>
<p><img src="/publications/external/volve-reservoir-model-evolution/README_files/figure-html/unnamed-chunk-25-1.png" width="672" style="display: block; margin: auto;" /></p>
</div>
<div id="calculate-cumulatives-for-oil-gas-and-water-for-monthly-period" class="section level3">
<h3>Calculate cumulatives for oil, gas and water for monthly period</h3>
<p>This is where we transform the dataframe from an heterogeneous date steps to monthly periods. We use the <em>group_by</em> function operating on the year and the month. This operation, in the end, brings us to a more organized table with a periodic variation. The extra work is recalculating the volumes and cumulatives on the new monthly basis. All these series of transformations are very common when you merge dataframes with different number of rows. What is happening here is:</p>
<ul>
<li>calculating the volume at the current period, which is the difference between the current row and the previous one. Wee do that with the <em>lag</em> function.</li>
<li>decomposing the date in year and month</li>
<li>grouping by year and month</li>
<li>summarize the data calculating the volumes per month</li>
<li>convert the (year, month) to (year, month, day) date format</li>
</ul>
<pre class="r"><code># step field totals
sim_cumulatives &lt;- 
step_totals %&gt;% 
    select(date, oil_otw, gas_otw, wat_otw) %&gt;% 
    mutate(oil_this_period = oil_otw - lag(oil_otw, default = 0)) %&gt;%
    mutate(gas_this_period = gas_otw - lag(gas_otw, default = 0)) %&gt;%
    mutate(wat_this_period = wat_otw - lag(wat_otw, default = 0)) %&gt;% 
    mutate(year = year(date), month = month(date)) %&gt;%
    group_by(year, month) %&gt;%
    summarize(vol_oil = sum(oil_this_period), 
              vol_gas = sum(gas_this_period), 
              vol_wat = sum(wat_this_period)) %&gt;%
    ungroup() %&gt;%
    mutate(date = ymd(paste(year, month, &quot;01&quot;, sep = &quot;-&quot;))) %&gt;%
    # mutate(source = &quot;simulator&quot;) %&gt;%
    mutate(cum_oil = cumsum(vol_oil), 
           cum_gas = cumsum(vol_gas), 
           cum_wat = cumsum(vol_wat)) %&gt;%
    select(date, year, month, everything()) %&gt;%
    print()
#&gt; # A tibble: 106 x 9
#&gt;    date        year month vol_oil  vol_gas vol_wat cum_oil  cum_gas cum_wat
#&gt;    &lt;date&gt;     &lt;dbl&gt; &lt;dbl&gt;   &lt;dbl&gt;    &lt;dbl&gt;   &lt;dbl&gt;   &lt;dbl&gt;    &lt;dbl&gt;   &lt;dbl&gt;
#&gt;  1 2008-01-01  2008     1       0        0       0       0   0.           0
#&gt;  2 2008-02-01  2008     2   30840  4884638       0   30840   4.88e6       0
#&gt;  3 2008-03-01  2008     3   90029 14117066       1  120869   1.90e7       1
#&gt;  4 2008-04-01  2008     4   73833 11469357   22292  194702   3.05e7   22293
#&gt;  5 2008-05-01  2008     5  124196 19115952  212550  318898   4.96e7  234843
#&gt;  6 2008-06-01  2008     6  137247 20967327  192961  456145   7.06e7  427804
#&gt;  7 2008-07-01  2008     7  155664 24005385  212739  611809   9.46e7  640543
#&gt;  8 2008-08-01  2008     8  170057 26420155  227653  781866   1.21e8  868196
#&gt;  9 2008-09-01  2008     9  163015 25205884  137169  944881   1.46e8 1005365
#&gt; 10 2008-10-01  2008    10  221230 33570835  317736 1166111   1.80e8 1323101
#&gt; # ... with 96 more rows</code></pre>
</div>
<div id="filling-the-date-gaps-with-periodic-dates" class="section level3">
<h3>Filling the date gaps with periodic dates</h3>
<p>In this case, at first sight, it seems that we got periodic dates for the production of the field. But what if we are missing a month or two? One way to ensure we have all months accounted for is building a known sequence of dates from <em>2016-01-01</em> until <em>2008-10-01</em>. That is what we do with the function <code>seq.Date()</code>:</p>
<p><code>seq.Date(as.Date(&quot;2008-01-01&quot;), as.Date(&quot;2016-10-01&quot;), by = &quot;month&quot;)</code></p>
<pre class="r"><code># create a dataframe with complete dates from 2008 until Oct-2016
# this will fill any holes in the dates of any of the two dataframes
dates_complete &lt;- as_tibble(data.frame(date= seq.Date(as.Date(&quot;2008-01-01&quot;), 
                                          as.Date(&quot;2016-10-01&quot;), by = &quot;month&quot;),
                 cum_oil = 0, cum_gas = 0, cum_wat = 0))
dates_complete
#&gt; # A tibble: 106 x 4
#&gt;    date       cum_oil cum_gas cum_wat
#&gt;    &lt;date&gt;       &lt;dbl&gt;   &lt;dbl&gt;   &lt;dbl&gt;
#&gt;  1 2008-01-01       0       0       0
#&gt;  2 2008-02-01       0       0       0
#&gt;  3 2008-03-01       0       0       0
#&gt;  4 2008-04-01       0       0       0
#&gt;  5 2008-05-01       0       0       0
#&gt;  6 2008-06-01       0       0       0
#&gt;  7 2008-07-01       0       0       0
#&gt;  8 2008-08-01       0       0       0
#&gt;  9 2008-09-01       0       0       0
#&gt; 10 2008-10-01       0       0       0
#&gt; # ... with 96 more rows</code></pre>
<p>So, there are 106 months from start to end of production.</p>
<p>Next, we proceed to merge the dataframe of known dates (above) with the dataframe <em>sim_cumulatives</em> that we obtained above. Finally, we calculate the volumes and cumulatives.</p>
<pre class="r"><code># simulator production
# merge incomplete dataframe and fill with complete dates
# there will be blank rows or NAs where previously was not data
sim_cumulatives_dt &lt;-
left_join(dates_complete, sim_cumulatives, by = &quot;date&quot;) %&gt;% 
    # remove NAs from the cumulatives .y
    tidyr::replace_na(list(cum_oil.y = 0, vol_oil = 0,
                           cum_gas.y = 0, vol_gas = 0,
                           cum_wat.y = 0, vol_wat = 0)) %&gt;%        # replace NAs with zeros
    # add up cumulatives .x and .y
    mutate(cum_oil = cum_oil.x + cum_oil.y, 
           cum_gas = cum_gas.x + cum_gas.y,
           cum_wat = cum_wat.x + cum_wat.y) %&gt;%       # sum cumulatives
    select(date, cum_oil, cum_gas, cum_wat, vol_oil, vol_gas, vol_wat) %&gt;%
    # replace 0s with previous cumulative. these were rows that didn&#39;t exist
    mutate(cum_oil = ifelse(cum_oil == 0, lag(cum_oil, default = 0), cum_oil)) %&gt;%
    mutate(cum_gas = ifelse(cum_gas == 0, lag(cum_gas, default = 0), cum_gas)) %&gt;%
    mutate(cum_wat = ifelse(cum_wat == 0, lag(cum_wat, default = 0), cum_wat)) %&gt;%
    mutate(vol_oil = ifelse(vol_oil == 0, lag(vol_oil, default = 0), vol_oil)) %&gt;%
    mutate(vol_gas = ifelse(vol_gas == 0, lag(vol_gas, default = 0), vol_gas)) %&gt;%
    mutate(vol_oil = ifelse(vol_wat == 0, lag(vol_wat, default = 0), vol_wat)) %&gt;%
    as_tibble() %&gt;% 
    print
#&gt; # A tibble: 106 x 7
#&gt;    date       cum_oil   cum_gas cum_wat vol_oil  vol_gas vol_wat
#&gt;    &lt;date&gt;       &lt;dbl&gt;     &lt;dbl&gt;   &lt;dbl&gt;   &lt;dbl&gt;    &lt;dbl&gt;   &lt;dbl&gt;
#&gt;  1 2008-01-01       0         0       0       0        0       0
#&gt;  2 2008-02-01   30840   4884638       0       0  4884638       0
#&gt;  3 2008-03-01  120869  19001704       1       1 14117066       1
#&gt;  4 2008-04-01  194702  30471061   22293   22292 11469357   22292
#&gt;  5 2008-05-01  318898  49587013  234843  212550 19115952  212550
#&gt;  6 2008-06-01  456145  70554340  427804  192961 20967327  192961
#&gt;  7 2008-07-01  611809  94559725  640543  212739 24005385  212739
#&gt;  8 2008-08-01  781866 120979880  868196  227653 26420155  227653
#&gt;  9 2008-09-01  944881 146185764 1005365  137169 25205884  137169
#&gt; 10 2008-10-01 1166111 179756599 1323101  317736 33570835  317736
#&gt; # ... with 96 more rows</code></pre>
<p>The negative volume of water and oil are possibly volume corrections by the operator.</p>
<pre class="r"><code># show observations with negative volumes
sim_cumulatives_dt %&gt;% 
  filter(vol_oil &lt;0 | vol_wat &lt; 0 | vol_gas &lt; 0)
#&gt; # A tibble: 2 x 7
#&gt;   date       cum_oil    cum_gas  cum_wat vol_oil vol_gas vol_wat
#&gt;   &lt;date&gt;       &lt;dbl&gt;      &lt;dbl&gt;    &lt;dbl&gt;   &lt;dbl&gt;   &lt;dbl&gt;   &lt;dbl&gt;
#&gt; 1 2016-09-01 9980819 1443979050 14400379  -50860 2640331  -50860
#&gt; 2 2016-10-01 9980819 1443979050 14400379  -50860 2640331       0</code></pre>
</div>
</div>
<div id="comparative-of-simulator-vs-historical-production" class="section level2">
<h2>Comparative of simulator vs historical production</h2>
<p>The last step is reading the historical production and compare them against the numbers from the simulation. We start by reading the historical production.</p>
<div id="reading-the-historical-production" class="section level3">
<h3>Reading the historical production</h3>
<p>Like we did in the previous article, we read the production history from an Excel file. But this time we will be reading all the variables in the dataset.</p>
<pre class="r"><code># load historical production from Excel file
library(xlsx)   # library to read Excel files in R

# read the Excel file
proj_root &lt;- rprojroot::find_rstudio_root_file()   # get the project root folder
xl_file &lt;- file.path(proj_root, &quot;inst/rawdata&quot;, &quot;Volve production data.xlsx&quot;)
# read only the monthly production
prod_hist &lt;- as_tibble(read.xlsx(xl_file, sheetName = &quot;Monthly Production Data&quot;))
prod_hist
#&gt; # A tibble: 529 x 10
#&gt;    Wellbore.name NPDCode  Year Month On.Stream Oil   Gas   Water GI   
#&gt;    &lt;fct&gt;           &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;fct&gt;     &lt;fct&gt; &lt;fct&gt; &lt;fct&gt; &lt;fct&gt;
#&gt;  1 15/9-F-4         5693  2007     9 NULL      NULL  NULL  NULL  NULL 
#&gt;  2 15/9-F-5         5769  2007     9 NULL      NULL  NULL  NULL  NULL 
#&gt;  3 15/9-F-4         5693  2007    10 NULL      NULL  NULL  NULL  NULL 
#&gt;  4 15/9-F-5         5769  2007    10 NULL      NULL  NULL  NULL  NULL 
#&gt;  5 15/9-F-4         5693  2007    11 NULL      NULL  NULL  NULL  NULL 
#&gt;  6 15/9-F-5         5769  2007    11 NULL      NULL  NULL  NULL  NULL 
#&gt;  7 15/9-F-4         5693  2007    12 NULL      NULL  NULL  NULL  NULL 
#&gt;  8 15/9-F-5         5769  2007    12 NULL      NULL  NULL  NULL  NULL 
#&gt;  9 15/9-F-4         5693  2008     1 0         NULL  NULL  NULL  NULL 
#&gt; 10 15/9-F-5         5769  2008     1 0         NULL  NULL  NULL  NULL 
#&gt; # ... with 519 more rows, and 1 more variable: WI &lt;fct&gt;</code></pre>
</div>
<div id="save-raw-production-history-to-data-files" class="section level3">
<h3>Save raw production history to data files</h3>
<p>Once we read the data from Excel we save it as a more standard format: <em>CSV</em>. But this saved data will be very raw because we haven’t performed any operation yet. That’s why we named it <em>production_history_raw.CSV</em>.</p>
<pre class="r"><code># save historical data as raw
data_folder &lt;- file.path(proj_root, &quot;data&quot;)
save(prod_hist, file = file.path(data_folder, &quot;production_history_raw.Rdata&quot;))
write.csv(prod_hist, file = file.path(data_folder, 
                                         &quot;production_history_raw.CSV&quot;), 
          row.names = FALSE)</code></pre>
</div>
<div id="cumulatives-from-production-history" class="section level3">
<h3>Cumulatives from production history</h3>
<p>These are the data transformations we will perform over the raw production data.</p>
<ul>
<li>convert from character to double, integer</li>
<li>replace the NAs with zeros</li>
<li>discard two columns with no meaningful data</li>
<li>rename the variables to all lowercase (easier to remember)</li>
<li>remove rows that have NAs</li>
<li>group by year and month</li>
<li>summarize by volumes</li>
<li>convert date from character to date format</li>
<li>sort the data by date</li>
<li>keep the variables we require</li>
<li>calculate the cumulatives from volumes</li>
</ul>
<pre class="r"><code>hist_cumulatives &lt;- 
prod_hist %&gt;% 
    mutate(Oil = as.double(as.character(Oil))) %&gt;%
    mutate(Gas = as.double(as.character(Gas))) %&gt;%
    mutate(Water = as.double(as.character(Water))) %&gt;% 
    mutate(Year = as.integer(as.character(Year))) %&gt;%
    mutate(Month = as.integer(as.character(Month))) %&gt;%
    mutate(GI = as.double(as.character(GI))) %&gt;%
    mutate(WI = as.double(as.character(WI))) %&gt;%
    tidyr::replace_na(list(GI = 0, WI = 0)) %&gt;%
    select(-c(NPDCode, On.Stream)) %&gt;% 
    rename(year = Year, month = Month, oil = Oil, gas = Gas, wat = Water) %&gt;% 
    na.omit() %&gt;%                 # remove all rows that have at least one NA
    group_by(year, month) %&gt;%
    summarise(vol_oil = sum(oil), vol_gas = sum(gas), vol_wat = sum(wat),
              vol_gi = sum(GI), vol_wi = sum(WI)) %&gt;%
    mutate(date = ymd(paste(year, month, &quot;01&quot;, sep = &quot;-&quot;))) %&gt;%
    arrange(date) %&gt;%
    ungroup() %&gt;%
    select(date, vol_oil, vol_gas, vol_wat, vol_gi, vol_wi) %&gt;%
    mutate(cum_oil = cumsum(vol_oil), cum_gas = cumsum(vol_gas),
           cum_wat = cumsum(vol_wat), 
           cum_gi = cumsum(vol_gi), cum_wi = cumsum(vol_wi)) %&gt;%
    print()
#&gt; # A tibble: 104 x 11
#&gt;    date       vol_oil vol_gas vol_wat vol_gi vol_wi cum_oil cum_gas cum_wat
#&gt;    &lt;date&gt;       &lt;dbl&gt;   &lt;dbl&gt;   &lt;dbl&gt;  &lt;dbl&gt;  &lt;dbl&gt;   &lt;dbl&gt;   &lt;dbl&gt;   &lt;dbl&gt;
#&gt;  1 2008-02-01  49091.  7.07e6   413.       0      0  4.91e4  7.07e6    413.
#&gt;  2 2008-03-01  83361.  1.22e7    27.4      0      0  1.32e5  1.93e7    440.
#&gt;  3 2008-04-01  74532.  1.15e7   482.       0      0  2.07e5  3.08e7    922.
#&gt;  4 2008-05-01 125479.  1.91e7 16280.       0      0  3.32e5  4.99e7  17202.
#&gt;  5 2008-06-01 143787.  2.15e7   474.       0      0  4.76e5  7.14e7  17677.
#&gt;  6 2008-07-01 166280.  2.47e7   416.       0      0  6.43e5  9.60e7  18093.
#&gt;  7 2008-08-01 165444.  2.39e7   577.       0      0  8.08e5  1.20e8  18669.
#&gt;  8 2008-09-01 192263.  2.75e7   464.       0      0  1.00e6  1.47e8  19134.
#&gt;  9 2008-10-01 237174.  3.38e7   725.       0      0  1.24e6  1.81e8  19859.
#&gt; 10 2008-11-01 250325.  3.57e7  2580.       0      0  1.49e6  2.17e8  22439.
#&gt; # ... with 94 more rows, and 2 more variables: cum_gi &lt;dbl&gt;, cum_wi &lt;dbl&gt;</code></pre>
<p>Observe that we’ve got 104 rows, which wouldn’t match the rows from the simulation data. We have to fix that. The problem is primarily dates.</p>
</div>
<div id="save-historical-cumulatives-as-is" class="section level3">
<h3>Save historical cumulatives as-is</h3>
<p>This saves the production history dataframe after the data transformations.</p>
<pre class="r"><code># save historical data
data_folder &lt;- file.path(proj_root, &quot;data&quot;)
save(hist_cumulatives, file = file.path(data_folder, &quot;hist_cumulatives_104.Rdata&quot;))
write.csv(hist_cumulatives, file = file.path(data_folder, 
                                         &quot;hist_cumulatives_104.CSV&quot;), 
          row.names = FALSE)</code></pre>
<pre class="r"><code># create a dataframe with complete dates from 2008 until Oct-2016
df &lt;- as_tibble(data.frame(date= seq.Date(as.Date(&quot;2008-01-01&quot;), 
                                          as.Date(&quot;2016-10-01&quot;), by = &quot;month&quot;),
                 cum_oil = 0, cum_gas = 0, cum_wat = 0))
df
#&gt; # A tibble: 106 x 4
#&gt;    date       cum_oil cum_gas cum_wat
#&gt;    &lt;date&gt;       &lt;dbl&gt;   &lt;dbl&gt;   &lt;dbl&gt;
#&gt;  1 2008-01-01       0       0       0
#&gt;  2 2008-02-01       0       0       0
#&gt;  3 2008-03-01       0       0       0
#&gt;  4 2008-04-01       0       0       0
#&gt;  5 2008-05-01       0       0       0
#&gt;  6 2008-06-01       0       0       0
#&gt;  7 2008-07-01       0       0       0
#&gt;  8 2008-08-01       0       0       0
#&gt;  9 2008-09-01       0       0       0
#&gt; 10 2008-10-01       0       0       0
#&gt; # ... with 96 more rows</code></pre>
<p>Remember that we created this date sequence above. This sequence had 106 rows.</p>
<pre class="r"><code>dates_complete
#&gt; # A tibble: 106 x 4
#&gt;    date       cum_oil cum_gas cum_wat
#&gt;    &lt;date&gt;       &lt;dbl&gt;   &lt;dbl&gt;   &lt;dbl&gt;
#&gt;  1 2008-01-01       0       0       0
#&gt;  2 2008-02-01       0       0       0
#&gt;  3 2008-03-01       0       0       0
#&gt;  4 2008-04-01       0       0       0
#&gt;  5 2008-05-01       0       0       0
#&gt;  6 2008-06-01       0       0       0
#&gt;  7 2008-07-01       0       0       0
#&gt;  8 2008-08-01       0       0       0
#&gt;  9 2008-09-01       0       0       0
#&gt; 10 2008-10-01       0       0       0
#&gt; # ... with 96 more rows</code></pre>
</div>
<div id="fill-the-dates-gap-in-the-production-history-dataframe" class="section level3">
<h3>Fill the dates gap in the production history dataframe</h3>
<p>We do almost the same data transformations as before:</p>
<ul>
<li>replace NAs in the variables with zeros</li>
<li>sum up the additional cumulative variables generated during the merge</li>
<li>replace a cumulative of zero by the previous cumulative (carry over). There cannot be cumulatives of zeros in between. That anomaly is caused by the absence of rows.</li>
<li>clean up the variables for gas injection (GI) and water injection (WI) volumes</li>
<li>calculate the cumulatives for gas injection and water injection</li>
</ul>
<pre class="r"><code># historical production
# merge incomplete dataframe and complete with dates
hist_cumulatives_dt &lt;- 
left_join(dates_complete, hist_cumulatives, by = &quot;date&quot;) %&gt;% 
    # replace NAs with zeros
    tidyr::replace_na(list(cum_oil.y = 0, cum_gas.y = 0, cum_wat.y = 0)) %&gt;%
    tidyr::replace_na(list(vol_oil = 0, vol_gas = 0, vol_wat = 0)) %&gt;%
    tidyr::replace_na(list(vol_gi = 0, vol_wi = 0, cum_gi = 0, cum_wi = 0)) %&gt;%
    # add up the extra column .y
    mutate(cum_oil = cum_oil.x + cum_oil.y) %&gt;%
    mutate(cum_gas = cum_gas.x + cum_gas.y) %&gt;%
    mutate(cum_wat = cum_wat.x + cum_wat.y) %&gt;%
    # filter(date != as.Date(&quot;2016-10-01&quot;)) %&gt;% 
    # this fixes the zeros generated by adding complete dates
    mutate(cum_oil = ifelse(cum_oil == 0, lag(cum_oil, default=0), cum_oil)) %&gt;%
    mutate(cum_gas = ifelse(cum_gas == 0, lag(cum_gas, default=0), cum_gas)) %&gt;%
    mutate(cum_wat = ifelse(cum_wat == 0, lag(cum_wat, default=0), cum_wat)) %&gt;%
    mutate(cum_gi = ifelse(cum_gi == 0, lag(cum_gi, default=0), cum_gi)) %&gt;% 
    mutate(cum_wi = ifelse(cum_wi == 0, lag(cum_wi, default=0), cum_wi)) %&gt;% 
    select(date, cum_oil, cum_gas, cum_wat, vol_oil, vol_gas, vol_wat, 
           vol_gi, vol_wi, cum_gi, cum_wi) %&gt;%
    as_tibble() %&gt;% 
    print
#&gt; # A tibble: 106 x 11
#&gt;    date       cum_oil cum_gas cum_wat vol_oil vol_gas vol_wat vol_gi vol_wi
#&gt;    &lt;date&gt;       &lt;dbl&gt;   &lt;dbl&gt;   &lt;dbl&gt;   &lt;dbl&gt;   &lt;dbl&gt;   &lt;dbl&gt;  &lt;dbl&gt;  &lt;dbl&gt;
#&gt;  1 2008-01-01  0.      0.          0       0   0.         0        0      0
#&gt;  2 2008-02-01  4.91e4  7.07e6    413.  49091.  7.07e6   413.       0      0
#&gt;  3 2008-03-01  1.32e5  1.93e7    440.  83361.  1.22e7    27.4      0      0
#&gt;  4 2008-04-01  2.07e5  3.08e7    922.  74532.  1.15e7   482.       0      0
#&gt;  5 2008-05-01  3.32e5  4.99e7  17202. 125479.  1.91e7 16280.       0      0
#&gt;  6 2008-06-01  4.76e5  7.14e7  17677. 143787.  2.15e7   474.       0      0
#&gt;  7 2008-07-01  6.43e5  9.60e7  18093. 166280.  2.47e7   416.       0      0
#&gt;  8 2008-08-01  8.08e5  1.20e8  18669. 165444.  2.39e7   577.       0      0
#&gt;  9 2008-09-01  1.00e6  1.47e8  19134. 192263.  2.75e7   464.       0      0
#&gt; 10 2008-10-01  1.24e6  1.81e8  19859. 237174.  3.38e7   725.       0      0
#&gt; # ... with 96 more rows, and 2 more variables: cum_gi &lt;dbl&gt;, cum_wi &lt;dbl&gt;</code></pre>
<p>Great! We got the dataframe <em>hist_cumulatives_dt</em>, with 106 rows and 11 columns.</p>
</div>
<div id="plot-production-rates" class="section level3">
<h3>Plot production rates</h3>
<p>If we want to plot several variables in one figure we have to convert the dataframe into tidy data format, and then use facets.</p>
<pre class="r"><code>hist_cumulatives_dt_gather &lt;- 
hist_cumulatives_dt %&gt;% 
  select(date, vol_oil, vol_gas, vol_wat) %&gt;% 
  gather(key = var, value, vol_oil:vol_wat) %&gt;% 
  
  print()
#&gt; # A tibble: 318 x 3
#&gt;    date       var       value
#&gt;    &lt;date&gt;     &lt;chr&gt;     &lt;dbl&gt;
#&gt;  1 2008-01-01 vol_oil      0 
#&gt;  2 2008-02-01 vol_oil  49091.
#&gt;  3 2008-03-01 vol_oil  83361.
#&gt;  4 2008-04-01 vol_oil  74532.
#&gt;  5 2008-05-01 vol_oil 125479.
#&gt;  6 2008-06-01 vol_oil 143787.
#&gt;  7 2008-07-01 vol_oil 166280.
#&gt;  8 2008-08-01 vol_oil 165444.
#&gt;  9 2008-09-01 vol_oil 192263.
#&gt; 10 2008-10-01 vol_oil 237174.
#&gt; # ... with 308 more rows</code></pre>
<p>And this is the plot of the cumulative variables from the production history.</p>
<pre class="r"><code># plot production variables from the STEP block in the PRT file

# order of the plots
hist_cumulatives_dt_gather$var_f &lt;- 
  factor(hist_cumulatives_dt_gather$var, 
         levels = c(&quot;vol_oil&quot;, &quot;vol_gas&quot;, &quot;vol_wat&quot;))

# change the name of the facet labels
facet_labels &lt;- c(`vol_oil` = &quot;Oil&quot;, `vol_gas` = &quot;Gas&quot;, `vol_wat` = &quot;Water&quot;)

ggplot(hist_cumulatives_dt_gather, aes(x = date, y = value, color = var)) +
  geom_line(size = 1) +
  facet_grid(var_f ~., scales = &quot;free_y&quot;,
             labeller = as_labeller(facet_labels)) +
  labs(title = &quot;Monthly fluid Volumes, m3&quot;, 
       subtitle = &quot;Historical Production&quot;, y = &quot;&quot;, x = &quot;&quot;)</code></pre>
<p><img src="/publications/external/volve-reservoir-model-evolution/README_files/figure-html/unnamed-chunk-38-1.png" width="576" style="display: block; margin: auto;" /></p>
</div>
<div id="save-historical-cumulatives-with-fixed-dates" class="section level3">
<h3>Save historical cumulatives with fixed dates</h3>
<p>We save the date fixed production history in CSV format file.</p>
<pre class="r"><code># save historical data with complete dates. 106 rows
data_folder &lt;- file.path(proj_root, &quot;data&quot;)
save(hist_cumulatives_dt, file = file.path(data_folder, &quot;hist_cumulatives_dt.Rdata&quot;))
write.csv(hist_cumulatives_dt, file = file.path(data_folder, &quot;hist_cumulatives_dt.CSV&quot;), 
          row.names = FALSE)</code></pre>
</div>
<div id="plot-historical-cumulatives-of-oil-gas-and-water" class="section level3">
<h3>Plot historical cumulatives of oil, gas and water</h3>
<pre class="r"><code>library(gridExtra)

# cumulative oil from historical production
p1 &lt;- ggplot(hist_cumulatives_dt, aes(x = date, y = cum_oil)) +
    geom_line() +
    geom_col(color = &quot;dark green&quot;, fill = &quot;dark green&quot;, alpha = 0.35) +
    ggtitle(&quot;Cumulative Oil, sm3&quot;, subtitle = &quot;Historical Production&quot;)

# cumulative gas from historical production
p2 &lt;- ggplot(hist_cumulatives_dt, aes(x = date, y = cum_gas)) +
    geom_line() +
    geom_col(color = &quot;orange&quot;, fill = &quot;orange&quot;, alpha = 0.35) +
    ggtitle(&quot;Cumulative Gas, sm3&quot;, subtitle = &quot;Historical Production&quot;)

# cumulative water from historical production
p3 &lt;- ggplot(hist_cumulatives_dt, aes(x = date, y = cum_wat)) +
    geom_line() +
    geom_col(color = &quot;blue&quot;, fill = &quot;blue&quot;, alpha = 0.35) +
    ggtitle(&quot;Cumulative Water, sm3&quot;, subtitle = &quot;Historical Production&quot;)

grid.arrange(p1, p2, p3, ncol =1)</code></pre>
<p><img src="/publications/external/volve-reservoir-model-evolution/README_files/figure-html/unnamed-chunk-40-1.png" width="480" style="display: block; margin: auto;" /></p>
</div>
<div id="rename-the-variables-according-to-source" class="section level3">
<h3>Rename the variables according to source</h3>
<p>Finally, because we want to combine the simulation results with the measured production for each fluid, on the same plot, we will rename the variables to something is directly recognizable as the source: simulator or historical.</p>
<p>These are the data transformations:</p>
<ul>
<li>rename the variables in the <em>sim_cumulatives_dt</em> dataframe</li>
<li>rename the variables in the <em>hist_cumulatives_dt</em> dataframe</li>
<li>join the resulting dataframe by the common variable <em>date</em></li>
</ul>
<pre class="r"><code># rename the simulation cumulatives
sim_cumulatives_src &lt;- 
sim_cumulatives_dt %&gt;% 
    select(date, cum_oil, cum_gas, cum_wat) %&gt;% 
    rename(cum_oil_sim = cum_oil, cum_gas_sim = cum_gas, cum_wat_sim = cum_wat)
    

# rename historical cumulatives according to source
hist_cumulatives_src &lt;- 
hist_cumulatives_dt %&gt;% 
    select(date, cum_oil, cum_gas, cum_wat) %&gt;% 
    rename(cum_oil_hist = cum_oil, cum_gas_hist = cum_gas, cum_wat_hist = cum_wat) 

# combine simulator and historical dataframes. common variable is &quot;date&quot;
cumulatives_all &lt;- full_join(hist_cumulatives_src, sim_cumulatives_src, by = &quot;date&quot;)
cumulatives_all
#&gt; # A tibble: 106 x 7
#&gt;    date       cum_oil_hist cum_gas_hist cum_wat_hist cum_oil_sim
#&gt;    &lt;date&gt;            &lt;dbl&gt;        &lt;dbl&gt;        &lt;dbl&gt;       &lt;dbl&gt;
#&gt;  1 2008-01-01           0            0            0            0
#&gt;  2 2008-02-01       49091.     7068009.         413.       30840
#&gt;  3 2008-03-01      132452.    19259180.         440.      120869
#&gt;  4 2008-04-01      206985.    30765621.         922.      194702
#&gt;  5 2008-05-01      332463.    49857492.       17202.      318898
#&gt;  6 2008-06-01      476250.    71369826.       17677.      456145
#&gt;  7 2008-07-01      642530.    96025129.       18093.      611809
#&gt;  8 2008-08-01      807974.   119948670.       18669.      781866
#&gt;  9 2008-09-01     1000237.   147475129.       19134.      944881
#&gt; 10 2008-10-01     1237411.   181232829.       19859.     1166111
#&gt; # ... with 96 more rows, and 2 more variables: cum_gas_sim &lt;dbl&gt;,
#&gt; #   cum_wat_sim &lt;dbl&gt;</code></pre>
<p>That’s it. Our final comparison dataframe with 106 rows and 7 columns.</p>
</div>
</div>
<div id="observations" class="section level2">
<h2>Observations</h2>
<p>In order to observe how close was the history matching, we plot the cumulative production from the simulator versus that of the historical production. Additionally, we want to shade the are between the two curves to show the difference.</p>
</div>
<div id="how-close-cumulative-productions-are" class="section level2">
<h2>How close cumulative productions are</h2>
<div id="cumulative-oil.-historical-vs-simulator" class="section level3">
<h3>Cumulative oil. Historical vs simulator</h3>
<pre class="r"><code># Volve reservoir model dataset
# plot historical vs simulator cum_oil

# manual assignment of colors in the legend
cols &lt;- c(&quot;simulator&quot;=&quot;red&quot;, &quot;historical&quot;=&quot;blue&quot;) # legend: colors and names
ggplot(cumulatives_all) +
    # shade the area between the curves
    geom_ribbon(aes(x = date, ymin= cum_oil_sim, ymax= cum_oil_hist), 
                fill = &quot;dark green&quot;, alpha = 0.35) + 
    geom_line(aes(x = date, y = cum_oil_sim, color = &quot;simulator&quot;)) +
    geom_line(aes(x = date, y = cum_oil_hist, color = &quot;historical&quot;)) +
    labs(title = &quot;Volve reservoir model. Comparison Cumulative Oil&quot;, 
         subtitle = &quot;Historical vs Simulator&quot;, 
         y = &quot;cumulative oil, sm3&quot;) +
    scale_color_manual(name = &quot;Curve&quot;, values = cols)  # manual legend</code></pre>
<p><img src="/publications/external/volve-reservoir-model-evolution/README_files/figure-html/unnamed-chunk-42-1.png" width="672" style="display: block; margin: auto;" /></p>
</div>
<div id="cumulative-gas.-historical-vs-simulator" class="section level3">
<h3>Cumulative gas. Historical vs simulator</h3>
<pre class="r"><code># Volve reservoir model dataset
# plot historical vs simulator cum_gas
cols &lt;- c(&quot;simulator&quot;=&quot;red&quot;, &quot;historical&quot;=&quot;blue&quot;) # legend: colors and names
ggplot(cumulatives_all) +
    # shade the area between the curves
    geom_ribbon(aes(x = date, ymin= cum_gas_sim, ymax= cum_gas_hist), 
                fill = &quot;orange&quot;, alpha = 0.35) + 
    geom_line(aes(x = date, y = cum_gas_sim, color = &quot;simulator&quot;), size = 1) +
    geom_line(aes(x = date, y = cum_gas_hist, color = &quot;historical&quot;), size = 1) +
    labs(title = &quot;Volve reservoir model. Comparison Cumulative Gas&quot;, 
         subtitle = &quot;Historical vs Simulator&quot;, 
         y = &quot;cumulative gas, sm3&quot;) +
    scale_color_manual(name = &quot;Curve&quot;, values = cols)  # manual legend</code></pre>
<p><img src="/publications/external/volve-reservoir-model-evolution/README_files/figure-html/unnamed-chunk-43-1.png" width="672" style="display: block; margin: auto;" /></p>
</div>
<div id="cumulative-water.-historical-vs-simulator" class="section level3">
<h3>Cumulative water. Historical vs simulator</h3>
<pre class="r"><code># Volve reservoir model dataset
# plot historical vs simulator cumulative water variable
cols &lt;- c(&quot;simulator&quot;=&quot;red&quot;, &quot;historical&quot;=&quot;blue&quot;) # legend: colors and names
ggplot(cumulatives_all) +
    # shade the area between the curves
    geom_ribbon(aes(x = date, ymin= cum_wat_sim, ymax= cum_wat_hist),
                fill = &quot;cyan&quot;, alpha = 0.35) +
    geom_line(aes(x = date, y = cum_wat_sim, color = &quot;simulator&quot;), size = 1) +
    geom_line(aes(x = date, y = cum_wat_hist, color = &quot;historical&quot;), size = 1) +
    labs(title = &quot;Volve reservoir model. Comparison Cumulative Water&quot;, 
         subtitle = &quot;Historical vs Simulator&quot;, 
         y = &quot;cumulative water, sm3&quot;) +
    scale_color_manual(name = &quot;Curve&quot;, values = cols)  # manual legend</code></pre>
<p><img src="/publications/external/volve-reservoir-model-evolution/README_files/figure-html/unnamed-chunk-44-1.png" width="672" style="display: block; margin: auto;" /></p>
<p><strong>Note.</strong> This last plot for the cumulative water has been observed different when another reservoir engineer <a href="https://www.linkedin.com/in/konstantin-sermyagin/?lipi=urn%3Ali%3Apage%3Ad_flagship3_messaging%3BMkGp%2FisTS7ehrKLYwnd%2Frw%3D%3D&amp;licu=urn%3Ali%3Acontrol%3Ad_flagship3_messaging-view_profile">Konstantin Sermyagin</a> was able to read directly from the Eclipse <strong>binary</strong> files. I have checked the cumulative water from the simulator and it has been properly extracted and transformed. Still, I have some doubts about the extraction of the cumulative water because the outflow doesn’t seem to originate from connate water but from injection water as well. If you download the Eclipse <strong>PRT</strong> file, please, take a look at the <strong>BALANCE AT</strong> blocks. Try to identify the variable corresponding to connate water only. I am not sure why Eclipse does not make a distinction between the two sources of water.</p>
</div>
</div>
<div id="datasets" class="section level2">
<h2>Datasets</h2>
<ul>
<li><p><a href="https://zenodo.org/record/2586212">Volve 2016 dataset for reservoir simulation model. Compressed PRT output as zip file</a>. Zenodo</p></li>
<li><p><a href="https://zenodo.org/record/2586209">Volve 2016 reservoir simulation PRT output file</a>. Zenodo.</p></li>
</ul>
</div>
</div>
